
	Web App Development:
	====================

	Manual Transaction:
	===================
	solution:
	Online Transaction App: web App : application works over browser
	=========================

	Customer1 --->	Customer2
		  <---
	===========================
	Smarter solution:
			quick,easy,safe,secured,
	Instant Banking: UPI Payments

	FSD : Full Stack Developer
	
		FrontEnd                  	backend
		html css bootstrap      	NodeJS    
		React				Java
						Python
						.Net
						PHP
	==============================================================================
		FreeCharge:
		----------
			Banking
		==============================
		Web App (fast,secued,easy,manageable,scalibilty).....

		Tools:
		=====
			VSCode
			Git
			

		HelloWorld Execution in JS
		==========================
		.txt
		.java
		.zip
	


		-----------------------------
		fileName.js
		Hello.html
		

		Step1: created a new Repo in github
		Step2: Installed Git in windows
		Step3: Created a new folder : exrecise
		Step4: Open GitBash and git init
		Step5: copied all files into repo downlaoded in exercise folder
		Step6: Navigate into repo
		Step6: git status
		Step7: git add .
		Step8: git status
		Step9: git commit -m "my first commit"
		STep10: git push origin main


	==========================================================================================
		NodeJS:
			node --version
			npm --version

		
		Files :
		------
			Syntax to read a file:
						fs.readFile(file_name,encoding,callback_function);

			Syntax to write a file:
						fs.writeFile(file_name,data,options,callback);
<<<<<<< HEAD
=======


			Callback: Function passed as an argument inside another function is called callback;

		JSON Server:
		------------
				It is a Node Module used to create demo REST [Representational State Transfer] JSON webservice.

				npm install -g json-server

				json-server --watch db.json

				CRUD Operations:

				Create
				Read
				Update
				Delete


				POSTMAN


				CaseSTudy : 01-Oct-2022
						-> Execute All samples
						-> Products: CRUD
								Products[name,cost,qty,code...]

				===================================================================================================

				Weekend:
					10 AM TO 5 PM:
					--------------
		
					Session + Lab

					10 AM to 12 AM ---> LAB [Execute All samples]
			
					12:30 PM to 2:30 PM ----> Session
	
					3:00 PM to 5:00 PM ----> LAB [CaseSTudy 2 : Products]

				===================================================================================================
				


>>>>>>> 7bf1a820098750e7ce0e68d81b2add97d5565374


			Callback: Function passed as an argument inside another function is called callback;

		JSON Server:
		------------
				It is a Node Module used to create demo REST [Representational State Transfer] JSON webservice.

				npm install -g json-server

				json-server --watch db.json

				CRUD Operations:

				Create
				Read
				Update
				Delete


				POSTMAN


				CaseSTudy : 01-Oct-2022
						-> Execute All samples
						-> Products: CRUD
								Products[name,cost,qty,code...]

				===================================================================================================

				Weekend:
					10 AM TO 5 PM:
					--------------
		
					Session + Lab

					10 AM to 12 AM ---> LAB [Execute All samples]
			
					12:30 PM to 2:30 PM ----> Session
	
					3:00 PM to 5:00 PM ----> LAB [CaseSTudy 2 : Products]

				===================================================================================================
				
					Data Structures:
					----------------
							A Data Structure is a storage that is used to store and organize data.
						Stack: LIFO : LAST IN FIRST OUT

						Queue:	FIFO
						
						List:	

						Algorithm:
						=========
							set of steps to achieve a goal or task

						 	1. Big O Notation :
										Big O(1) --->  good
										Big O(n!) ---> horrible

							2. Search Algorithm :  Linear Search and Bonary Search.
							3. Sorting Algorithm:	Bubble Sort,Selection Sort etc....


							n * (n - 1)

							3
							  2
						            1 ---> 
								= 6


							Linear Search:
							-------------
								Step 1. Linear Search will accept an array and a target value.
								Step 2. Start searching from the beginning of the array.
								Step 3. check if the value is equals to target:
									-> If so,stop and return values index.
									-> If not.move on to the next element.
								Step 4.	Repeat step3 untill all elements are checked.
										If target not found return -1.


							Binary Search:
							--------------
						Step 1. Start in middle and check if the target is greater or less than middle value.
						Step 2. If the target is greater than the middle value,we will next look at the second half of the array.
						Step 3. If the target is smaller, we look at the first haf of the array.
						Step 4. We pick the middle of that half and  check if its greater or less than our target.
						Step 5. Repeat this process until we find our Target.
									If target not found return -1.


							Sorting:
							=======
								Organising an array of elements into a specific order.
							[4,8,2] ----> SORT ----> [2,4,8]

							Bubble Sort:
							------------
									
							Step1. Start at the beginning of the array
							Step2. Is the adjacent element to the right less? If so ,swap
							step3. Move to next element
							Step4. Repeat steps 2 and 3 util array is sorted.

							[3,2,4,1] ---->   is 3 > 2 => yes : [2,3,4,1]
							[2,3,4,1] ---->   is 3 > 4 => no  : dont swap
							[2,3,4,1] ---->   is 4 > 1 => yes : [2,3,1,4] 

							[2,3,1,4] ---->   is 2 > 3 => no : dont swap
							[2,3,1,4] ---->   is 3 > 1 => yes : [2,1,3.4]
							[2,1,3,4] ---->   4 is the biggest

							[2,1,3,4] ---> is 2 > 1 => yes [1,2,3,4]
							SORTED


							Selection Sort:
							----------------

							Step1: Input Array --> [5,2,4,6,1,3]
							Step2: Start at element1 (5) and set it as the minumum value.
							Step3: compare element1 (5) with elemen2 (2). 2 < 5 ,so set 2 as the new minimum value.
							Step4: Move to element3 (4).
							Step5: 4 < 2? No,move to element4 (6)
							Step6: 6 < 2?  No,move to element5 (1)
							Step7: 1 < 2? Yes,so set 1 as the new minimum
							Step8: Move to element6 (3)
							Step9: 3 < 1? No.
							Step10: we are at end of the array so swap element1 (5) <- our minimum element element5 (1)
								[1,2,4,6,5,3]

							Merge Sort:
							===========
									Merge sort works by decomposing an array into smaller arrays of 0 or 1 items,
							then building up a newly sorted array.

							First we divide the array up until we get arrays of 0 or 1 item		
							
							Unit Testing:
							=============
									Mocha and Chai

								npm init
								npm install mocha chai	
											
							module or component or unit

							actaul value === expected value

	=======================================================================================================================================


		Error and Exceptional Handling:
		-------------------------------
						1) syntax Errors
						2) Logical error
						3) Runtime Error:
								try{

								}catch(){
								}
								finally{
								}
	======================================================================================================================================

		Write a JS to send an email:
		
		from 
		to
		Sub
		Body

=============================================================================================================================================


		Web & Network Fundamentals:
		===========================			
				
			Web:    http or https <----- Internet
			---
				Web App Development
						web service or Rest API

						REST API: Representational State Transfer

						API:
							Application Programing Interface

						Server:   web server
						=======		
							Node provide http Server  ----> localhost:5000
				
		===============================================================================================

			JavaScript:  ------> ECMAScript or ES2015 ---> ES6			
			----------

			1: New ES6 Syntax
			2: Destructuring
			3: ES6 Modules
			4: ES6 Classes
			5: Arrow Functions
			6: Symbol
			7: Iterators & Generators
			8: Promises - Async /Await
			9: ES6 Collections
			10: Array Extensions
			11: Object Extenstions
			12: String Extensions
			


			1. New ES6 syntax:
			-----------------
						JavaScript let: Declaring Block-Scoped Variables
							In ES5 : we declare a variable using var keyword.(scope of the variable is eithrer global or local)
							In ES6 : Provides let keyword.(these variables are blocked-scope).

							Syntax: let variable_name;
			
		
							const keyword creates read only reference to a value.
							The read only reference cannot be reassigned but the value can be change.
				//start...
				function1(p1,function2){
					function2();
				}

				function2(p2,function3){

				function3()
				}

				....
				....
				functionN(Pn,functionN){
				}

				//result: success or failure or pending..... CALLBACK HELL
				// Promise

				Promises:
				========	
					By Definition,a promise is an Object that encapsulates the result of an asynchronous operation.

					A promise Object has a state that can be :
						1) Pending
						2) Fulfiled with a value
						3) Rejected for a reason.


						Syntax:
						======
							const promise = new Promise((resolve,reject) => {
							//.... operation or task
							if(success){
							   resolve(value);
							}else {
							  reject(error);
							}
							})
						
						then() Method:
						-------------
								To get a value of a Promise when its fulfilled,you call then() of thr Promise Object.

							promise.then(onFulfilled,onRejected);








			Lets Maintain a Transaction history: ES6 Syntax
			===============================================

			Users Module:
			=============
					Create Read Update Delete



			Transaction:
			============
				-> User should be logged In
				-> Transaction Amount should be less than Current Balance
				

		
			Assignemnts:
			===========

			HTML5 AND CSS3:
			---------------
			-> SignUp Form
			-> Login Form
			-> Home Page or Dashboard

			   =============================================================
			   Home   Users   Transactions                            Logout

						

			  Users Page(Data Table in jquery with search) => Should list all users with edit and delete Option.

			  Transactions Page (Data Table in jquery with search) => User Should enter all trasanction details.

			JSON-SERVER:
			===========
				users-data.json
				const users-data = {
							userid:
							username:
							password:
							email:
							phone:		
							gender:
							age:
							city:
							state:
							pincode:
							country:
						  }


			   const transactions = {

					         transactionId:
						 fromUser:			
						 toUser:
						 transaction amount:
						 transaction date:
						 transaction time:
						 transacation status:

						}

			======================================================================================================================	

			JavaScript DOM:  Document Object Model
			===============		

			DOM is an application programming interface (API) for manipulating HTML documents.
			The DOM represents an HTML document as a tree of nodes.
			The DOM provides functions that allows you to add,remove and modify parts of document effectively.

			<html>
			   <head>
				<title>JavaScript DOM </title>
			   </head>

			   <body>
				<p> Hello DOM!!! </p>
			   </body>

			</html>

		 	-----------------------------------------------------------------------------------------
			docuement.getElementById(): 
					returns an Element object that represents an HTML element with an id that matches a specified string.
					If the docuemt has no element with the specified id, it returns null.
			document.getElementsByName():

			document.getElementsByTagName():



========================================================================================================================================

			View:
				HTML5 CSS3 JS ( Angular or React ) + BootStrap  TESTING

			Backend: NodeJS
					Express.js<- Framework

				Testing Postman

			DataBases:PostgreSQL,MongoDB

			Documentation using Swagger
	
========================================================================================================================================

		Files:
		------
			

		DBMS:
		----
			DataBase Management System
				Database ia a collection of interrelated data which helps in the efficient retrieval,insertion and deletion of data
				from the database and organizes the data in the form of tables,views,schemas,reports etc....


				 examples:
						university database organizes the data about students,faculty,admim staff,departments etc...
						
				There are four types of Data Languages:
				1) DDL: Data Definition Language					
				2) DML: Data Manipulation Language
				3) DCL: Data Control Language
				4) TCL: Transactional Control Language
			
					1) DDL: Data Definition Language:
					   ==============================
									deals with how data should reside in the database:
									CREATE : creates a database and tables etc...
									ALTER : alters the structure of the existing database
									DROP : delete objects from the database
									TRUNCATE : remove all records from a table
									RENAME: rename an object

					2) DML: Data Manipulation Language:
					   ================================
									deals with data manipulation and includes most common SQL statements suchas
									SELECT,INSERT,UPDATE,DELETE etc.... 
									Its used to store,modify,retrieve,delete and update in a database.
									SELECT: retriee data from a database
									INSERT: insert data into a table
									UPDATE:  updates existing data within a table
									DELETE: Delete all records from a database table

					3) DCL: Data Control Language:
					   ===========================
									DCL acts as an access specifier to the database.(basically grant and revoke permissions
									to users in the database)

									GRANT:
										grant permissions to the user for running DML(SELECT,INSERT,DELETE,..)
										commands on the table
									REVOKE:
										revoke permissions to the user for running DML (SELECT,INSERT,DELETE,..)
										on the specified table.

					4) TCL: Transactional Control Language:
						==============================
										acts as an manager for all types of transactional data and all transactions.

										RoleBack: Used to cancel or Undo changes made in the database
										Commit: Its Used to apply or save changes in the database
										Save Point: Its used to save the data on the temporary basis in the database.

			

			CRUD Operation:
			--------------
			
					Database : sampleDB
						Table : users
							id   email   password  	

				Step 1: show databases; 
						Lists All existing Databases
				Step 2: create database testDB;
						Creates a new Database.

				Step 3: use testDB;

				Step 4: create table users(id int,email varchar(50),password varchar(50));


				Step 5:  show tables;


				Step 6: desc users;

				Step 7: insert into users(id,email,password) values (101,"alex@gmail.com","123456");
			
				Step 8: select * from users;

				Step 9: select * from users where id = 101;

				Step 10: update users set password = "888888" where id = 103;

				Step 11: delete from users where id = 103;

				Step 12: delete from users; <- deletes all users from the table

			-> PostGres
			-> MySQL
			-> NoSQL-mongoDB

			


			9:30 AM to 6:30 PM
			-------------------

			9:30 AM to 11:15 AM  <---    Session
			11:30 PM to 1:30 PM  <---    Lab
			1:30 PM to 2:30 PM   <---    Lunch Break
			2:30 PM to 4:30 PM   <---    Session
			4:30 PM to 6:30 PM   <---    Lab


			PostGres:
			--------
				Its an ORDBMS[Open Source Object Relational DataBase Management System].
				Used to store data securely.
				
			create database sampleDB;
			\c sampleDB <- to connect db
			\d users <- describes the table
			\d <- lists tables
			insert into users(userid,username,password) values (1,'John','123456');
			insert into users(userid,username,password) values (2,'Jimmy','123456'),(3,'Julie','123456');

			OrderBy:
			-------
				select username from users order by username;


			Group By:
			---------
				

				create table Employee(id int,firstName text,lastName text,salary real);
				insert into Employee() values(101,'Alex','N',200000); 


			Having:
			-------
				select firstname,SUM(salary) from employee GROUP BY firstname HAVING SUM(salary) > 50000 order by firstname DESC;

				select firstname,SUM(salary) from employee GROUP BY firstname HAVING SUM(salary) < 50000 order by firstname DESC;

				select * from employee ORDER BY firstname FETCH first 1 ROW ONLY;				
		
				select * from employee where id < 104 AND firstname = 'Niel';

				select * from employee where id < 104 AND salary > 50000;
				
				select * from employee,users;

				select * from users;

				select * from employee where users.username = employee.firstname;

				select * from employee,users where users.username = employee.firstname;
				
				select * from employee,users where users.username = employee.firstname;

				select * from employee,users where users.username = employee.firstname AND id = 101;

				select * from employee,users where users.username = employee.firstname AND id = 102;

				select * from employee,users where users.username = employee.firstname AND salary > 20000;

				 select * from employee,users where users.username = employee.firstname OR salary < 20000;

				select * from employee,users where users.username = employee.firstname OR salary < 20000;
				
				select * from employee,users where users.username = employee.firstname OR salary < 400000;

				select * from employee,users where users.username = employee.firstname AND salary < 400000;

				select * from employee,users where (users.username = employee.firstname OR salary < 400000) AND id < 103;

				 select * from employee WHERE firstname NOT IN('Alex','Bob')  ORDER BY id;

				select * from employee WHERE salary BETWEEN 100000 AND 500000 ORDER BY id DESC;

				 select * from employee WHERE salary >= 100000 AND salary <= 300000 ORDER BY id DESC;

				select * from employee WHERE salary >= 100000 AND salary <= 500000 ORDER BY id DESC;

				select * from employee where employee.firstname LIKE '%e%';

				select * from employee where id NOT IN (101,102);

				select * from employee where id NOT IN (101,102);

				select * from employee WHERE age BETWEEN 23 and 25;

				Constraints:
				============
						used to describe the rules for the data columns in a table.
						
				NOT NULL:
						its used to make sure that a column canot have a null value.	

				
					

				UNIQUE:
					Unique constraint is used to mintain the individuality of the values we store in a 
					field or acolumn of the	table.


				PRIMARY KEY:
						Unique and not null constraint.

						Each table can have only one primary key.
					create table nominee(id SERIAL PRIMARY KEY,name varchar(50),email varchar(50),phone varchar(50));

						id     name      email     phone
						1
						2
						
						
		
						
				FOREIGN KEY:
						
				create table account(acc_id int,nominee_id int, PRIMARY KEY(acc_id),CONSTRAINT fk_nominee_id FOREIGN KEY(nominee_id) REFERENCES nominee(id));
						
						acc_id   nominee_id(Foreign Key)

			
				Join:
				-----
					it will be used with SELECT command which helps to fetch data from multiple tables.

					SELECT columns
					FROM table1
					INNER JOIN table2
					ON table1.column = table2.column;

					INNER JOIN:
					-----------
							SELECT * from nominee INNER JOIN account ON nominee.id = account.nominee_id;


					LEFT JOIN:
					----------
							return all rows from left table,which can define in the ON condition and only those rows from the 
							other table where the join condition is satisified.

					SELECT columns
					FROM table1
					LEFT JOIN table2
					ON table1.column = table2.column;
						



					Right Join:
					-----------

							return all rows from right table,which can define in the ON condition and only those rows from the 
							other table where the join condition is satisified.

					SELECT columns
					FROM table1
					RIGHT JOIN table2
					ON table1.column = table2.column;


					Full Outer Join:
					---------------
							used to return all records when there is a match in the left table or right table records.



					SELECT columns
					FROM table1
					FULL OUTER JOIN table2
					ON table1.column = table2.column;


					Triggers:
					---------
						user defined function connected with a table.
						-> create a trigger function
						-> bind the same trigger function to a table.				
							

						Create Trigger:
						===============
						Syntax:
								CREATE FUNCTION trigger_function()
								 RETURNS TRIGGER
								 LANGUAGE PLPGSQL
								AS $$

								BEGIN
								  -- trigger logic
								END;
								$$


								CREATE TRIGGER trigger_name
								{BEFORE | AFTER}{event}
								ON table_name
								[FOR [EACH] { ROW | STATEMENT}]
								EXECUTE PROCEDURE trigger_function

CREATE OR REPLACE FUNCTION log_name_changes()
RETURNS TRIGGER
LANGUAGE PLPGSQL
AS
$$
BEGIN
IF NEW.name <> OLD.name THEN
INSERT INTO nominee(id,name,email,phone) VALUES (OLD.ID,OLD.name,OLD.email,OLD.phone);
END IF;
RETURN NEW;
END;
$$


create FUNCTION transfer(
sender int,
reciever int,
amount dec
)
returns trigger
language plpgsql
as $$
begin
-- substracting the amount from the sender's account
update accounts
set balance = balance - amount
where id = sender;
--adding the amount to the reciever's account
update accounts
set balance = balance + amount
where id = reciever;
commit;
end;$$


		

	Assignment List:
	---------------


		 	Assignment 21:
		 	--------------
				Create a Table with name : BRANCH
				with fields: BRANCH_CODE CHAR(4) NOT NULL
					     BRANCH_NAME VARCHAR(40) NOT NULL	     
					     BRANCH_ADDRESS1 VARCHAR(60) NOT NULL
					     BRANCH_ADDRESS2 VARCHAR(60)
					     BRANCH_CITY VARCHAR(30) NOT NULL
					     BRANCH_ZIP VARCHAR(10) NOT NULL
					     BRANCH_STATE CHAR(2) NOT NULL

	
		
			     	Create a Table with name : CUSTOMER
			     	with fields:
					CUST_NO  INT NOT NULL
					BRANCH_CODE CHAR(4) NOT NULL
					CUST_USERNAME VARCHAR(16) NOT NULL
					CUST_PASSWORD VARCHAR(10) NOT NULL
					CUST_EMAIL VARCHAR(40)
					CUST_TITLE VARCHAR(3) NOT NULL
					CUST_GIVENNAMES VARCHAR(40) NOT NULL
					CUST_SURNAME VARCHAR(40) NOT NULL
					CUST_ADDRESS1 VARCHAR(60) NOT NULL
					CUST_ADDRESS2 VARCHAR(60) 
					CUST_CITY VARCHAR(30) NOT NULL
					CUST_ZIP VARCHAR(10) NOT NULL
					CUST_STATE CHAR(2) NOT NULL
 

				Create a Table with name : ACCOUNT_TYPE
			     	with fields:
					ACCTYPE_ID CHAR(3) NOT NULL
					ACCTYPE_DESC VARCHAR(30) NOT NULL
					ACCTYPE_INTERESTRATE DECIMAL(4,2) DEFAULT 0.0

				Create a Table with name : ACCOUNT
			     	with fields:
					BRANCH_CODE  CHAR(4)  NOT NULL
					ACC_NO  CHAR(8) NOT NULL		
					CUST_NO  INT  NOT NULL
					ACCTYPE_ID CHAR(3) NOT NULL
					ACC_BALANCE DECIMAL(10,2) DEFAULT 0.0


				Create a Table with name : TRANSACTION_TYPE
			     	with fields:
					TRANSTYPE_ID CHAR(4) NOT NULL
					TRANSTYPE_DESC VARCHAR(40) NOT NULL

				Create a Table with name : TRANSACTION_HISTORY
			     	with fields:
					TRANS_ID LONGINT NOT NULL
					BRANCH_CODE CHAR(4) NOT NULL
					ACC_NO  CHAR(8) NOT NULL
					TRANSTYPE_ID  CHAR(4) NOT NULL
					TRANS_POSTDATE TIMESTAMP NOT NULL
					TRANS_DESC VARCHAR(40)
					TRANS_AMOUNT DECIMAL(10,2) NOT NULL


			Assignment 22:
			--------------
					Write a SQL statement to add a primary key for the columns BRANCH_CODE in the BRANCH table.
			Assignment 23:
			--------------
					Write a SQL statement to add a foreign key constraint named fk_branch_code on branch_code column 
					on Branch_Code of Customer Table referencing to the primary key Branch_Code of Branch Table.

			Assignment 24:
			--------------
					Write a SQL statement to change the email column of the CUSTOMER table.

			Assignment 25:
			--------------

					Write a SQL statement to change the TRANS_AMOUNT of an TRANSACTION_HISTORY to 8000, 
					if the existing TRANS_AMOUNT is less than 5000.

			Assignemnt 26:
			--------------

					MongoDB: maintaining a relationship between customer_accounts to branch.

				db.bank.find(); it should list all brances with its customers
				db.bank.find({'branch-code':'01'}) 

					
			       Bank-Branch1     ------> Customer1,Customer2,Customer3 ...etc....	
				    Branch2	------> Customer4,Customer5,Customer6 ...etc....
				    Branch3	------> Customer7,Customer8,Customer9 ...etc....
				    Branch4	------> Customer10,Customer11,Customer12...etc....
				

				

					
				

			
				

 



 
 



 

		 
		 
		
		 

	
							

				


















			Http Request  -------->  path ,controller_function   ----------> ,controller_function   (){}  --------> MongoDB/postgres


			
		
			Users Module:   create User,List users,update Users,delete Users 
			-------------

				UI	               NodeJS - Express.js					 DataBase
			    BootStrap	 APIs        								  PostGres	
					POST http://localhost:3001/users/create
					GET  http://localhost:3001/users/get_all_users				DB Name: myApp
					GET  http://localhost:3001/users/get_user_by_id/id			Table Name: users
					PUT  http://localhost:3001/users/update_user_by_id/id			id,email,password,dob,phone,street,area
				     DELETE  http://localhost:3001/users/delete_user_by_id/id			pincode state country


					POST http://localhost:3001/flight/create
					GET  http://localhost:3001/flights/get_all_flights
					GET  http://localhost:3001/flights/get_flight_by_id/id
					PUT  http://localhost:3001/flights/update_user_by_id/id
					DELETE  http://localhost:3001/flights/delete_user_by_id/id		

				Monolithic Architecture
				UI                   NodeJS: 3001                               PostGres: 5432 (or)
												mongoDB: 27017
							Users                                    users table
							Flights                                 flights table


				Micro Services:
				----------------

			UI		UsersModule : 3001        PostGres : usersDB
					npm start

					Transactions: 3002        mongoDB  : transactionsDB
				    	npm start

					Reports:      3003        Postgres : reportsDB
					npm start


					API Gateway,Rabbit MQ
					
	
					Eureka Client Discovery


					Development : Micro Services
					Testing : 
					Deployment : Docker and DockerHub (Introduction to CI/CD )
				


			=========================================================================================

			=> POST  User Registration or SignUp [user saved in db]

			=> POST User Login or Sign In

			Step1:
			POST Login Request ====>  username and Password
							======> validate credentails(compare the user input values with values in db)
								========> if user is matched return success else return "invalid credentails"
			Step2:
			JWT : JSON Web Token

					 if user is matched return 
					{
					"status":"success"
					"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTIzNDU2Nzg5LCJuYW1lIjoiS
						   m9zZXBoIn0.OpOSSw7e485LOP5PrzScxHb7SR6sAOMRckfFwi4rp7o" 
					}
			=========================================================================================

			

			

			PostGres-Node JS Connectivity:
			-----------------------------

			step1: npm init -y
			step2: npm install pg
			step3: create db.js

			






				
			MongoDB:
			-------
			Installation				
							
			use demoDB;
			collections                               tables
			document					rows and columns
			{
			  "email":"alex@gmail.com",
			  "password":"123456"
			}	


			
			db.users.insertOne({"_id":"001","email":"bob@gmail.com","password":"123456"},{ forceServerObjectId:false})

			db.users.update({"_id":"001"},{$set:{"password":"888888"}})			

			db.users.deleteMany({"email":"bob@gmail"})								
			
			Query and Projection Operator:
			------------------------------
				Syntax: {<field>:{$eq: <value>}}

					
					"db.customer.find({c_age:{$gt:22}})        

					db.customer.find({c_age:{$gt:22}}).count()

					db.customer.find({c_age:{$gt:21}}).count()

					db.customer.find({c_age:{$lt:24}}).count()

					db.customer.find({c_age:{$in:[21,24]}}).count()

					db.customer.find({c_age:{$ne:21}}).count()

					db.customer.find({c_age:{$nin:[21,24]}}).count()

					db.customer.find({c_age:{$lte:21}}).count()

					db.customer.find({age:{$not:{$gt:22}}})

					db.customer.find({age:{$not:{$gt:21}}})

db.customer.find({age:{$not:{$gt:24}}})

db.customer.find({age:{$not:{$gt:21}}})

db.customer.find({$and:[{age:{$ne:24}},{age:{$exists:true}}]})

 db.customer.find({$and:[{age:{$ne:24}},{age:{$exists:true}}]}).count()

 db.customer.find({$and:[{age:{$ne:22}},{age:{$exists:true}}]}).count()

db.customer.find({$and:[{age:{$ne:22}},{age:{$exists:false}}]}).count()

 db.customer.find({$and:[{c_age:{$ne:22}},{c_age:{$exists:true}}]}).count()

db.customer.find({$and:[{c_age:{$ne:22}},{c_age:{$exists:true}}]}).count()

db.customer.find({c_age:{$exists:true}}).count()

db.customer.find({c_age:{$exists:false}}).count()

"

	Aggregation in MongoDB:
	----------------------
				aggregation operations process the data records/documents and return computed results.
				It collects values from various documents and groups them togeather and then performs 
				different types of operations on that grouped data like sum,average,minimum.maximum etc to return a computed result.

				MongoDB provides 3 ways to perform aggregation:

				1. Aggregation pipeline:
					aggregation pipeline is a multi stage pipeline,so in each state,the documents are taken as input and produce
					the resultant set of documents ,next the resultant document taken as input and produce output.
					
					


					db.train.aggregate([{$match:{class:"first-class"}},{$group:{_id:"id",total:{$sum:"$fare"}}}])

					db.train.aggregate([{$group:{_id:"id",total:{$sum:"$fare"}}}])
                                                         stage        expression      Accumulator
					
					$group:
						stage groups the documents by id field to calculate the sum of fare for each unique id.

					Stages:
						Each stage starts from stage operators:
						$match:
							Its used for filtering the documents can reduce the amount of documents that are given as
							input to the next stage.
						$project:
							Its used to select some specific fields from a collection.

						$group:
							Its used to group documents based on some value.

						$sort:
							used to sort documents (re arranging them)


						$skip:
							skip n number of documents and passes the remaining documents

						$out: used to write resulting documents to a new collection.



					Expressions:
							It refers to the name of the field in input documents.
						Example: {$group:{_id:"$id",total:{$sum:"$fare"}}}
								$id and $fare are expressions.

					
					Accumulator:
							used in the group stage
						sum: sums numeric values for the document in each group
						count: counts total numbers of documents
						avg: It calculates the avg of all given values from all documents.
						min: minimum value from all the documents.
						max: gets maximum value from all the documents
						first: gets the first document from the grouping
						last: gets the last document from the grouping.

						db.train.aggregate([{$match:{class:'first-class'}},{$count:"Total count of  first class"}])


						db.train.aggregate([{$group:{_id:"$id",total:{$sum:1},max_fare:{$max:"$fare"}}}])
			
						db.train.aggregate([{$group:{_id:"$id",total:{$sum:1},min_fare:{$min:"$fare"}}}])



				
				2. Map-reduce function:
							Its used for aggregating results for the large volume of data.
							Map Reduce has two main functions one is map that groups all the documents and the second 
							one is the reduce which performs opreation on the grouped data.

							db.collectionName.mapReduce(mappingFunction,reduceFunction, {out:'Result'});

							var mapfunction = function(){emit(this.id,this.fare)}
							var reducefunction = function(key,values){return Array.sum(values)}
							db.train.mapReduce(mapfunction,reducefunction,{'out':'Results'})
								{ result: 'Results', ok: 1 }

							db.Results.find()

							[ { _id: '101', value: 3200 }, { _id: '102', value: 1200 } ]


				3. Single-purpose aggregation:
							Its used when we need simple access to document like counting the number of documents or for
					finding all distinct values in a document.


					It simply provides the access to the common aggregation process using the count(), distinct() and
					estimatedDocumentCount() methods, so due to which it lacks the flexibilty and capabolities of the pipeline.

							db.train.distinct("class")
							db.train.distinct("fare)


			
				
			
				
				SDLC: SOftware Developemnt Life Cycle:

				--> Requirement Gathering [BRS,CRS,SRS,FRS]
				--> Analysis or Feasibility Study
				--> Design (HLD or LLD) [TDD,FDD]
				--> Coding				
				--> Testing <-  STLC[SOFTWARE TEST LIFE CYCLE]
				--> Implementation
				--> Maintainence								     DEPLOYMENT
							DEVELOPMENT SERVER or STAGING SERVER OR LOCAL SERVER     ==================> PRODUCTION SERVER
							[domain name or IP]							     CLIENT'S SERVER
				[ Development   --> SCM TOOLS(GitLab)  -----> Merged or Comibined -----> Testing ]      BUILD		LIVE SERVER

				D1  M1

				D2  M2

				D3  M3

				D4  M4

				D5  M5

				D6  M6

				
				WebApps: SPA,Responsive...... [mobile browsers]

				Mobile App: iPhone : .ipa
					    Android : .apk

				Hybrid Apps or Native Apps


				PWAs: Progresive Web Apps

				
					
				SECURITY : OAuth 2.0 ---> JWT JSON Web Token
						ROLE MANAGEMENT  <-- admin 
								 <-- user 
								 <-- client 
			


				
				UI                      BACKEND                MODEL                                Testing			 Build Tools         Swagger UI    kafka,RabbitMQ     Deployment
			Angular or React	    NodeJS                      mysql,mongo,posgtres			Mocha,Jest and Ezyme	  Docker,Gradle		yes		 etc		aws,cloud etc
			Bootsrap UI		    Java,.Net,PHP,Golang        DynamoDB,couchbase server...		Junit,Selenium...		Maven etc.					jenkins
			Material UI





			Docker:
			-------
				Introduction:
				=============
						mysql server or mongodb
						nodejs

						build an image and upload that into docker hub
						
				Installation:
				============
		
				Commands:
				=========
						docker --version
						docker images <- lists all images
						docker ps -a <- lists all running images

						docker pull hello-world
						docker run hello-world
		
						docker stop container-id <- to stop running conatiner image
						docker rm container-id <- to remove image from container


						navigate to products api : docker-compose up


						

							

						orders service:	http://localhost:3005/orders

						products service: http://localhost:3006/products
			
						API Gateway: 	http://localhost:3007/products
								http://localhost:3007/orders


					
						




					Order:  mongo


					Product:  






			Project Details:
			1. PPT : Presentation
			2. Model : Design or FLow Chart
			3. Number of Micro Services:
			4. Tools: Swagger UI,POSTman,NodeJS,Express.js,PostGres or MySQL
			5. Testing : Unit Testing [Mocha and CHai]
			6. Logs
			
			




















		
						
